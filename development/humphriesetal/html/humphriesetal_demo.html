
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Demo for state-dependent delays --- example from Humpries etal (DCDS-A 2012)</title><meta name="generator" content="MATLAB 7.14"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2014-04-10"><meta name="DC.source" content="humphriesetal_demo.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }

  </style></head><body><div class="content"><h1>Demo for state-dependent delays --- example from Humpries etal (DCDS-A 2012)</h1><!--introduction--><p>
% $Id: humphriesetal_demo.html 20 2014-04-11 19:27:33Z jan.sieber $
</p><p>Humphries et al ( A. R. Humphries,  O. A. DeMasi, F. M. G. Magpantay,  F. Upham (2012), <i>Dynamics of a delay differential equation with multiple state-dependent delays</i>, Discrete and Continuous Dynamical Systems 32(8) pp. 2701-2727 <a href="http://dx.doi.org/10.3934/dcds.2012.32.2701">http://dx.doi.org/10.3934/dcds.2012.32.2701</a>)</p><p>consider a scalar DDE with two state-dependent delays:</p><p><img src="humphriesetal_demo_eq04710.png" alt="$$x'(t)=-\gamma x(t)-\kappa_1 x(t-a_1-c x(t))-\kappa_2 x(t-a_2-c x(t))\mbox{.}$$"></p><p>The system exhibits double Hopf bifurcations, folds of periodic orbits and torus bifurcations, which can be computed and demonstrated using DDE-Biftool.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Add path to DDE-Biftool</a></li><li><a href="#2">Function definitions (right-hand side and delays)</a></li><li><a href="#3">Trivial equilibrium branch</a></li><li><a href="#4">Periodic orbits branching off from 1st Hopf bifurcation</a></li><li><a href="#5">One-parameter bifurcation diagram for family of periodic orbits</a></li><li><a href="#7">Hopf bifurcation in two parameters</a></li><li><a href="#8">Fold of periodic orbits</a></li><li><a href="#10">Torus bifurcation continuation</a></li><li><a href="#12">Stability of periodic orbits along torus bifurcation</a></li></ul></div><h2>Add path to DDE-Biftool<a name="1"></a></h2><pre class="codeinput">clear
close <span class="string">all</span>
addpath(<span class="string">'../../ddebiftool/'</span>,<span class="keyword">...</span>
    <span class="string">'../../ddebiftool_extra_psol/'</span>,<span class="keyword">...</span>
    <span class="string">'../../ddebiftool_utilities/'</span>);
</pre><h2>Function definitions (right-hand side and delays)<a name="2"></a></h2><p>Define the right-hand side and the state-dependent delays. We also provide their derivatives (in separate functions) to speed up execution.</p><p>Order of the parameters: <tt>p(1:2)=kappa1:2, p(3:4)=a1:2, p(5)=gamma, p(6)=c</tt></p><pre class="codeinput">rhs=@(x,p)-p(5)*x(1,1,:)-p(1)*x(1,2,:)-p(2)*x(1,3,:);
sys_ntau=@()2;
tau=@(nr,x,p)p(2+nr)+p(6)*x(1,1,:);
drhs=@(x,p,nx,np,v)sys_deri_humphries_etal(rhs,x,p,nx,np,v);
dtau=@(nr,x,p,nx,np)sys_dtau_humphries_etal(tau,nr,x,p,nx,np);
funcs=set_funcs(<span class="string">'sys_rhs'</span>,rhs,<span class="string">'sys_ntau'</span>,sys_ntau,<span class="string">'sys_tau'</span>,tau,<span class="keyword">...</span>
    <span class="string">'sys_deri'</span>,drhs,<span class="string">'sys_dtau'</span>,dtau,<span class="string">'x_vectorized'</span>,true);
par_ini=[0,2.3,1.3,6,4.75,1];
indkappa1=1;
indkappa2=2;
</pre><h2>Trivial equilibrium branch<a name="3"></a></h2><p>The equilibrium <img src="humphriesetal_demo_eq02368.png" alt="$x=0$"> changes its stability in Hopf bifurcations</p><pre class="codeinput">[eqbr,suc]=SetupStst(funcs,<span class="string">'contpar'</span>,indkappa1,<span class="string">'x'</span>,0,<span class="string">'parameter'</span>,par_ini,<span class="keyword">...</span>
    <span class="string">'max_bound'</span>,[indkappa1,12],<span class="string">'max_step'</span>,[indkappa1,0.1]);
<span class="keyword">if</span> ~suc
    error(<span class="string">'equilibrium not found'</span>);
<span class="keyword">end</span>
clf
eqbr=br_contn(funcs,eqbr,100);
<span class="comment">% stability</span>
[eqnunst,dom,triv_defect,eqbr.point]=<span class="keyword">...</span>
GetStability(eqbr,<span class="string">'funcs'</span>,funcs,<span class="string">'points'</span>,2:length(eqbr.point));
</pre><img vspace="5" hspace="5" src="humphriesetal_demo_01.png" alt=""> <h2>Periodic orbits branching off from 1st Hopf bifurcation<a name="4"></a></h2><p>We continue the periodic orbits in <tt>parameter(1)</tt> (<tt>kappa1</tt>), and calculate their stability.</p><pre class="codeinput">indhopf=find(eqnunst&gt;0,1,<span class="string">'first'</span>);
[per,suc]=SetupPsol(funcs,eqbr,indhopf,<span class="string">'contpar'</span>,indkappa1,<span class="string">'degree'</span>,5,<span class="string">'intervals'</span>,30,<span class="keyword">...</span>
    <span class="string">'print_residual_info'</span>,1,<span class="string">'radius'</span>,1e-2);
<span class="keyword">if</span> ~suc
    error(<span class="string">'initialization of periodic orbits failed'</span>);
<span class="keyword">end</span>
per.parameter.max_step=[indkappa1,0.3];
per=br_contn(funcs,per,200);
disp(<span class="string">'calculate stability'</span>)
[pernunst,dom,triv_defect,per.point]=<span class="keyword">...</span>
    GetStability(per,<span class="string">'exclude_trivial'</span>,true,<span class="string">'funcs'</span>,funcs); <span class="comment">%#ok&lt;*ASGLU&gt;</span>
fprintf(<span class="string">'maximum error of trivial Floquet multiplier: %g\n'</span>,max(abs(triv_defect)));
</pre><pre class="codeoutput">it=1, res=0.00670715
it=2, res=5.70491e-06
it=3, res=2.7812e-12
it=1, res=0.0171466
it=2, res=2.54493e-06
it=3, res=8.88453e-14
it=1, res=3.03196e-09
it=1, res=0.0462999
it=2, res=5.17741e-05
it=3, res=3.97891e-08
it=4, res=2.14688e-14
it=1, res=0.0612862
it=2, res=0.000409528
it=3, res=1.4835e-06
it=4, res=1.48815e-11
it=1, res=1.59646e-08
it=2, res=2.21728e-14
it=1, res=0.0680922
it=2, res=0.000754814
it=3, res=3.24181e-06
...</pre><img vspace="5" hspace="5" src="humphriesetal_demo_02.png" alt=""> <h2>One-parameter bifurcation diagram for family of periodic orbits<a name="5"></a></h2><p>Continuation parameter is <img src="humphriesetal_demo_eq95756.png" alt="$\kappa_1$">.</p><pre class="codeinput">ppars=arrayfun(@(x)x.parameter(1),per.point);
pmeshes=cell2mat(arrayfun(@(x)x.mesh(:),per.point,<span class="string">'uniformoutput'</span>,false));
pprofs=cell2mat(arrayfun(@(x)x.profile(1,:)',per.point,<span class="string">'uniformoutput'</span>,false));
clf
clrs=colormap(<span class="string">'lines'</span>);
pernunst_cases=unique(pernunst);
amp=max(pprofs)-min(pprofs);
hold <span class="string">on</span>
lstr={};
<span class="keyword">for</span> i=1:length(pernunst_cases);
    sel=pernunst==pernunst_cases(i);
    plot(ppars(sel),amp(sel),<span class="string">'o'</span>,<span class="string">'color'</span>,clrs(i,:));
    lstr={lstr{:},sprintf(<span class="string">'#unst=%d'</span>,pernunst_cases(i))}; <span class="comment">%#ok&lt;CCAT&gt;</span>
<span class="keyword">end</span>
hold <span class="string">off</span>
grid <span class="string">on</span>
xlabel(<span class="string">'\kappa_1'</span>);
ylabel(<span class="string">'amplitude'</span>);
legend(lstr,<span class="string">'location'</span>,<span class="string">'southeast'</span>);
grid <span class="string">on</span>
</pre><img vspace="5" hspace="5" src="humphriesetal_demo_03.png" alt=""> <pre class="codeinput">save(<span class="string">'humphries1dbif.mat'</span>);
</pre><h2>Hopf bifurcation in two parameters<a name="7"></a></h2><p>Continuation parameters are <img src="humphriesetal_demo_eq95756.png" alt="$\kappa_1$"> and <img src="humphriesetal_demo_eq70036.png" alt="$\kappa_2$">.</p><pre class="codeinput">figure(2);clf
[hbranch1,suc]=SetupHopf(funcs,eqbr,indhopf,<span class="keyword">...</span>
    <span class="string">'contpar'</span>,[indkappa1,2],<span class="string">'dir'</span>,indkappa1,<span class="string">'step'</span>,0.1,<span class="keyword">...</span>
    <span class="string">'max_bound'</span>,[indkappa1,12; indkappa2,10],<span class="keyword">...</span>
    <span class="string">'min_bound'</span>,[indkappa1,0; indkappa2,0],<span class="keyword">...</span>
    <span class="string">'max_step'</span>,[indkappa1,0.1; indkappa2,0.1]);
<span class="keyword">if</span> ~suc
    error(<span class="string">'Hopf initialization failed'</span>);
<span class="keyword">end</span>
clf
hbranch1=br_contn(funcs,hbranch1,100);
hbranch1=br_rvers(hbranch1);
hbranch1=br_contn(funcs,hbranch1,100);
hpars=cell2mat(arrayfun(@(x)x.parameter(1:2)',hbranch1.point,<span class="string">'uniformoutput'</span>,false));
</pre><pre class="codeoutput">BR_CONTN warning: boundary hit.
BR_CONTN warning: boundary hit.
</pre><img vspace="5" hspace="5" src="humphriesetal_demo_04.png" alt=""> <h2>Fold of periodic orbits<a name="8"></a></h2><p>Continuation parameters are <img src="humphriesetal_demo_eq95756.png" alt="$\kappa_1$"> and <img src="humphriesetal_demo_eq70036.png" alt="$\kappa_2$">. We remove stepsize restrictions for parameters, increase the maximum number of Newton iterations. The stability along the fold may indicate codimensions. However, increasing <tt>triv_defect</tt> indicates increasing errors in Floquet multiplier computations.</p><pre class="codeinput">pf_ind0=find(diff(pernunst)==1,1,<span class="string">'first'</span>);
per.method.point.print_residual_info=1;
per.parameter.max_step=[];
per.method.point.newton_max_iterations=8;
[pfuncs,pbr,suc]=SetupPOfold(funcs,per,pf_ind0,<span class="string">'contpar'</span>,[indkappa1,indkappa2],<span class="keyword">...</span>
    <span class="string">'dir'</span>,indkappa2,<span class="string">'step'</span>,-0.01);
<span class="keyword">if</span> ~suc
    error(<span class="string">'initialization of fold of periodic orbits failed'</span>);
<span class="keyword">end</span>
</pre><pre class="codeoutput">it=1, res=3.08797
it=2, res=204.739
it=3, res=13.8964
it=4, res=0.10911
it=5, res=2.02177e-06
it=6, res=1.60907e-11
it=1, res=6.90913
it=2, res=0.109275
it=3, res=3.54579e-06
it=4, res=1.68807e-11
it=1, res=5.03447
it=2, res=2.5498
it=3, res=0.00157249
it=4, res=2.57639e-09
it=1, res=3.53685
it=2, res=0.137775
it=3, res=1.54648e-06
it=4, res=1.80291e-11
</pre><pre class="codeinput">figure(2);
pbr=br_contn(pfuncs,pbr,220);
pbr=br_rvers(pbr);
pbr=br_contn(pfuncs,pbr,60);
pforbits=pfuncs.get_comp(pbr.point,<span class="string">'solution'</span>);
[pfstab,dom,triv_defect,pforbitstab]=GetStability(pforbits,<span class="string">'exclude_trivial'</span>,true,<span class="keyword">...</span>
    <span class="string">'locate_trivial'</span>,@(p)[1,1],<span class="string">'funcs'</span>,funcs);
pfpars=cell2mat(arrayfun(@(x)x.parameter(1:2)',pbr.point,<span class="string">'uniformoutput'</span>,false));
pfmeshes=cell2mat(arrayfun(@(x)x.mesh(:),pbr.point,<span class="string">'uniformoutput'</span>,false));
pfprofs=cell2mat(arrayfun(@(x)x.profile(1,:)',pbr.point,<span class="string">'uniformoutput'</span>,false));
pf_amp=max(pfprofs)-min(pfprofs);
save(<span class="string">'humphries_pofold.mat'</span>);
</pre><pre class="codeoutput">it=1, res=4.67569
it=2, res=0.237738
it=3, res=8.1448e-06
it=4, res=1.57667e-11
it=1, res=8.65029
it=2, res=0.0106624
it=3, res=1.00242e-07
it=4, res=1.87544e-11
it=1, res=4.97287
it=2, res=0.0112096
it=3, res=8.28609e-09
it=1, res=15.6081
it=2, res=0.0563395
it=3, res=3.99449e-06
it=4, res=1.63558e-11
it=1, res=19.9819
it=2, res=0.0517287
it=3, res=1.94464e-06
it=4, res=1.68261e-11
it=1, res=25.2063
...</pre><img vspace="5" hspace="5" src="humphriesetal_demo_05.png" alt=""> <h2>Torus bifurcation continuation<a name="10"></a></h2><p>Continuation parameters are <img src="humphriesetal_demo_eq95756.png" alt="$\kappa_1$"> and <img src="humphriesetal_demo_eq70036.png" alt="$\kappa_2$">.</p><pre class="codeinput">tr_ind0=find(diff(pernunst)==2,1,<span class="string">'first'</span>);
[trfuncs,trbr,suc]=SetupTorusBifurcation(funcs,per,tr_ind0,<span class="keyword">...</span>
    <span class="string">'contpar'</span>,[indkappa1,indkappa2],<span class="string">'dir'</span>,indkappa2,<span class="string">'step'</span>,-0.01);
<span class="keyword">if</span> ~suc
    error(<span class="string">'initialization of torus bifurcation failed'</span>);
<span class="keyword">end</span>
</pre><pre class="codeoutput">it=1, res=1.86284
it=2, res=0.117783
it=3, res=9.31292e-05
it=4, res=7.96251e-09
it=1, res=0.000106411
it=2, res=4.74679e-11
it=1, res=0.644099
it=2, res=0.0584185
it=3, res=2.90345e-05
it=4, res=2.84816e-08
it=5, res=4.46003e-11
it=1, res=8.53383e-05
it=2, res=8.48063e-11
</pre><pre class="codeinput">figure(2);
trbr=br_contn(trfuncs,trbr,80);
trbr=br_rvers(trbr);
trbr=br_contn(trfuncs,trbr,40);
</pre><pre class="codeoutput">it=1, res=0.168894
it=2, res=8.17217e-05
it=3, res=4.22518e-09
it=1, res=0.255921
it=2, res=0.000166909
it=3, res=1.25776e-08
it=4, res=7.84441e-13
it=1, res=0.000127848
it=2, res=6.26392e-11
it=1, res=0.391092
it=2, res=0.000343442
it=3, res=3.57833e-08
it=4, res=1.33626e-12
it=1, res=0.600864
it=2, res=0.000717279
it=3, res=9.8836e-08
it=4, res=3.52034e-12
it=1, res=0.92931
it=2, res=0.00160062
it=3, res=2.69597e-07
...</pre><img vspace="5" hspace="5" src="humphriesetal_demo_06.png" alt=""> <h2>Stability of periodic orbits along torus bifurcation<a name="12"></a></h2><p>The code below demonstrates how one can use <tt>GetStability</tt> and its optional argument <tt>'locate_trivial'</tt> to exclude the known critical Floquet multipliers from the stability consideration. Thus, the stability changes along the torus bifurcation help detect codimension-two bifurcations.</p><pre class="codeinput">trorbits=trfuncs.get_comp(trbr.point,<span class="string">'solution'</span>);
trrot=trfuncs.get_comp(trbr.point,<span class="string">'omega'</span>);
trorbits=arrayfun(@(x,y)setfield(x,<span class="string">'parameter'</span>,[x.parameter,y]),trorbits,trrot);
trivial_floqs=@(p)[1,exp(1i*p.parameter(end)*pi),exp(-1i*p.parameter(end)*pi)];
[trstab,dom,triv_defect,trorbitstab]=GetStability(trorbits,<span class="string">'exclude_trivial'</span>,true,<span class="keyword">...</span>
    <span class="string">'locate_trivial'</span>,trivial_floqs,<span class="string">'funcs'</span>,funcs);
</pre><p>Extract parameters, meshes and profiles of orbits at torus bifurcation</p><pre class="codeinput">trpars=cell2mat(arrayfun(@(x)x.parameter(1:2)',trbr.point,<span class="string">'uniformoutput'</span>,false));
trmeshes=cell2mat(arrayfun(@(x)x.mesh(:),trbr.point,<span class="string">'uniformoutput'</span>,false));
trprofs=cell2mat(arrayfun(@(x)x.profile(1,:)',trbr.point,<span class="string">'uniformoutput'</span>,false));
tr_amp=max(trprofs)-min(trprofs);
trmu=cell2mat(arrayfun(@(x)x.stability.mu(1:10),trorbitstab,<span class="string">'uniformoutput'</span>,false));
</pre><p>plot profiles of orbits at torus bifurcation</p><pre class="codeinput">figure(3);clf
plot(trmeshes,trprofs);
grid <span class="string">on</span>
xlabel(<span class="string">'t/T'</span>);
ylabel(<span class="string">'x'</span>);
</pre><img vspace="5" hspace="5" src="humphriesetal_demo_07.png" alt=""> <p>bifucation diagram</p><pre class="codeinput">figure(2);clf
hold <span class="string">on</span>
unstabsel=trstab&gt;0;
lw={<span class="string">'linewidth'</span>,2};
plot(trpars(1,unstabsel),trpars(2,unstabsel),<span class="string">'ro'</span>,<span class="string">'markersize'</span>,4,<span class="string">'markerfacecolor'</span>,<span class="string">'r'</span>,lw{:});
plot(hpars(1,:),hpars(2,:),<span class="string">'k-'</span>,<span class="keyword">...</span>
    trpars(1,:),trpars(2,:),<span class="string">'r-'</span>,<span class="keyword">...</span>
    pfpars(1,:),pfpars(2,:),<span class="string">'b-'</span>,lw{:});
set(gca,<span class="string">'xlim'</span>,[0,12],<span class="string">'ylim'</span>,[0,4]);
grid <span class="string">on</span>
xlabel(<span class="string">'\kappa_1'</span>);
ylabel(<span class="string">'\kappa_2'</span>);
legend({<span class="string">'torus bif (unstab)'</span>,<span class="string">'Hopf'</span>,<span class="string">'torus bif'</span>,<span class="string">'fold'</span>},<span class="keyword">...</span>
    <span class="string">'location'</span>,<span class="string">'southwest'</span>);
</pre><img vspace="5" hspace="5" src="humphriesetal_demo_08.png" alt=""> <pre class="codeinput">save(<span class="string">'humphries_2dbif.mat'</span>);
</pre><p class="footer"><br>
      Published with MATLAB&reg; 7.14<br></p></div><!--
##### SOURCE BEGIN #####
%% Demo for state-dependent delays REPLACE_WITH_DASH_DASH- example from Humpries etal (DCDS-A 2012)
%
% <html>
% $Id: humphriesetal_demo.html 20 2014-04-11 19:27:33Z jan.sieber $
% </html>
%
% Humphries et al ( A. R. Humphries,  O. A. DeMasi,
% F. M. G. Magpantay,  F. Upham (2012), _Dynamics of a delay differential equation
% with multiple state-dependent delays_, Discrete and Continuous Dynamical
% Systems 32(8) pp. 2701-2727 <http://dx.doi.org/10.3934/dcds.2012.32.2701>)
%
% consider a scalar DDE with two state-dependent delays:
% 
% $$x'(t)=-\gamma x(t)-\kappa_1 x(t-a_1-c x(t))-\kappa_2 x(t-a_2-c x(t))\mbox{.}$$
%
% The system exhibits double Hopf bifurcations, folds of periodic orbits
% and torus bifurcations, which can be computed and demonstrated using
% DDE-Biftool.
%%
%% Add path to DDE-Biftool
clear
close all
addpath('../../ddebiftool/',...
    '../../ddebiftool_extra_psol/',...
    '../../ddebiftool_utilities/');
%% Function definitions (right-hand side and delays)
% Define the right-hand side and the state-dependent delays. We also provide their
% derivatives (in separate functions) to speed up execution.
% 
% Order of the parameters: 
% |p(1:2)=kappa1:2, p(3:4)=a1:2, p(5)=gamma, p(6)=c|
rhs=@(x,p)-p(5)*x(1,1,:)-p(1)*x(1,2,:)-p(2)*x(1,3,:);
sys_ntau=@()2;
tau=@(nr,x,p)p(2+nr)+p(6)*x(1,1,:);
drhs=@(x,p,nx,np,v)sys_deri_humphries_etal(rhs,x,p,nx,np,v);
dtau=@(nr,x,p,nx,np)sys_dtau_humphries_etal(tau,nr,x,p,nx,np);
funcs=set_funcs('sys_rhs',rhs,'sys_ntau',sys_ntau,'sys_tau',tau,...
    'sys_deri',drhs,'sys_dtau',dtau,'x_vectorized',true);
par_ini=[0,2.3,1.3,6,4.75,1];
indkappa1=1;
indkappa2=2;
%% Trivial equilibrium branch
% The equilibrium $x=0$ changes its stability in Hopf bifurcations
[eqbr,suc]=SetupStst(funcs,'contpar',indkappa1,'x',0,'parameter',par_ini,...
    'max_bound',[indkappa1,12],'max_step',[indkappa1,0.1]);
if ~suc
    error('equilibrium not found');
end
clf
eqbr=br_contn(funcs,eqbr,100);
% stability
[eqnunst,dom,triv_defect,eqbr.point]=...
GetStability(eqbr,'funcs',funcs,'points',2:length(eqbr.point));
%% Periodic orbits branching off from 1st Hopf bifurcation
% We continue the periodic orbits in |parameter(1)| (|kappa1|), and calculate
% their stability.
indhopf=find(eqnunst>0,1,'first');
[per,suc]=SetupPsol(funcs,eqbr,indhopf,'contpar',indkappa1,'degree',5,'intervals',30,...
    'print_residual_info',1,'radius',1e-2);
if ~suc
    error('initialization of periodic orbits failed');
end
per.parameter.max_step=[indkappa1,0.3];
per=br_contn(funcs,per,200);
disp('calculate stability')
[pernunst,dom,triv_defect,per.point]=...
    GetStability(per,'exclude_trivial',true,'funcs',funcs); %#ok<*ASGLU>
fprintf('maximum error of trivial Floquet multiplier: %g\n',max(abs(triv_defect)));
%% One-parameter bifurcation diagram for family of periodic orbits
% Continuation parameter is $\kappa_1$.
ppars=arrayfun(@(x)x.parameter(1),per.point);
pmeshes=cell2mat(arrayfun(@(x)x.mesh(:),per.point,'uniformoutput',false));
pprofs=cell2mat(arrayfun(@(x)x.profile(1,:)',per.point,'uniformoutput',false));
clf
clrs=colormap('lines');
pernunst_cases=unique(pernunst);
amp=max(pprofs)-min(pprofs);
hold on
lstr={};
for i=1:length(pernunst_cases);
    sel=pernunst==pernunst_cases(i);
    plot(ppars(sel),amp(sel),'o','color',clrs(i,:));
    lstr={lstr{:},sprintf('#unst=%d',pernunst_cases(i))}; %#ok<CCAT>
end
hold off
grid on
xlabel('\kappa_1');
ylabel('amplitude');
legend(lstr,'location','southeast');
grid on
%%
save('humphries1dbif.mat');
%% Hopf bifurcation in two parameters
% Continuation parameters are $\kappa_1$ and $\kappa_2$.
figure(2);clf
[hbranch1,suc]=SetupHopf(funcs,eqbr,indhopf,...
    'contpar',[indkappa1,2],'dir',indkappa1,'step',0.1,...
    'max_bound',[indkappa1,12; indkappa2,10],...
    'min_bound',[indkappa1,0; indkappa2,0],...
    'max_step',[indkappa1,0.1; indkappa2,0.1]);
if ~suc
    error('Hopf initialization failed');
end
clf
hbranch1=br_contn(funcs,hbranch1,100);
hbranch1=br_rvers(hbranch1);
hbranch1=br_contn(funcs,hbranch1,100);
hpars=cell2mat(arrayfun(@(x)x.parameter(1:2)',hbranch1.point,'uniformoutput',false));
%% Fold of periodic orbits
% Continuation parameters are $\kappa_1$ and $\kappa_2$. We remove stepsize
% restrictions for parameters, increase the maximum number of Newton
% iterations. The stability along the fold may indicate codimensions.
% However, increasing |triv_defect| indicates increasing errors in Floquet
% multiplier computations.
pf_ind0=find(diff(pernunst)==1,1,'first');
per.method.point.print_residual_info=1;
per.parameter.max_step=[];
per.method.point.newton_max_iterations=8;
[pfuncs,pbr,suc]=SetupPOfold(funcs,per,pf_ind0,'contpar',[indkappa1,indkappa2],...
    'dir',indkappa2,'step',-0.01);
if ~suc
    error('initialization of fold of periodic orbits failed');
end
%%
figure(2);
pbr=br_contn(pfuncs,pbr,220);
pbr=br_rvers(pbr);
pbr=br_contn(pfuncs,pbr,60);
pforbits=pfuncs.get_comp(pbr.point,'solution');
[pfstab,dom,triv_defect,pforbitstab]=GetStability(pforbits,'exclude_trivial',true,...
    'locate_trivial',@(p)[1,1],'funcs',funcs);
pfpars=cell2mat(arrayfun(@(x)x.parameter(1:2)',pbr.point,'uniformoutput',false));
pfmeshes=cell2mat(arrayfun(@(x)x.mesh(:),pbr.point,'uniformoutput',false));
pfprofs=cell2mat(arrayfun(@(x)x.profile(1,:)',pbr.point,'uniformoutput',false));
pf_amp=max(pfprofs)-min(pfprofs);
save('humphries_pofold.mat');
%% Torus bifurcation continuation
% Continuation parameters are $\kappa_1$ and $\kappa_2$. 
tr_ind0=find(diff(pernunst)==2,1,'first');
[trfuncs,trbr,suc]=SetupTorusBifurcation(funcs,per,tr_ind0,...
    'contpar',[indkappa1,indkappa2],'dir',indkappa2,'step',-0.01);
if ~suc
    error('initialization of torus bifurcation failed');
end
%%
figure(2);
trbr=br_contn(trfuncs,trbr,80);
trbr=br_rvers(trbr);
trbr=br_contn(trfuncs,trbr,40);
%% Stability of periodic orbits along torus bifurcation
% The code below demonstrates how one can use |GetStability| and its optional
% argument |'locate_trivial'| to exclude the known critical Floquet
% multipliers from the stability consideration. Thus, the stability changes
% along the torus bifurcation help detect codimension-two bifurcations.
trorbits=trfuncs.get_comp(trbr.point,'solution');
trrot=trfuncs.get_comp(trbr.point,'omega');
trorbits=arrayfun(@(x,y)setfield(x,'parameter',[x.parameter,y]),trorbits,trrot);
trivial_floqs=@(p)[1,exp(1i*p.parameter(end)*pi),exp(-1i*p.parameter(end)*pi)];
[trstab,dom,triv_defect,trorbitstab]=GetStability(trorbits,'exclude_trivial',true,...
    'locate_trivial',trivial_floqs,'funcs',funcs);
%% 
% Extract parameters, meshes and profiles of orbits at torus bifurcation
trpars=cell2mat(arrayfun(@(x)x.parameter(1:2)',trbr.point,'uniformoutput',false));
trmeshes=cell2mat(arrayfun(@(x)x.mesh(:),trbr.point,'uniformoutput',false));
trprofs=cell2mat(arrayfun(@(x)x.profile(1,:)',trbr.point,'uniformoutput',false));
tr_amp=max(trprofs)-min(trprofs);
trmu=cell2mat(arrayfun(@(x)x.stability.mu(1:10),trorbitstab,'uniformoutput',false));
%% 
% plot profiles of orbits at torus bifurcation
figure(3);clf
plot(trmeshes,trprofs);
grid on
xlabel('t/T');
ylabel('x');
%%
% bifucation diagram
figure(2);clf
hold on
unstabsel=trstab>0;
lw={'linewidth',2};
plot(trpars(1,unstabsel),trpars(2,unstabsel),'ro','markersize',4,'markerfacecolor','r',lw{:});
plot(hpars(1,:),hpars(2,:),'k-',...
    trpars(1,:),trpars(2,:),'r-',...
    pfpars(1,:),pfpars(2,:),'b-',lw{:});
set(gca,'xlim',[0,12],'ylim',[0,4]);
grid on
xlabel('\kappa_1');
ylabel('\kappa_2');
legend({'torus bif (unstab)','Hopf','torus bif','fold'},...
    'location','southwest');
%%
save('humphries_2dbif.mat');
##### SOURCE END #####
--></body></html>
